// #########################################################
// #########################################################
//                      HEADER CODE
// #########################################################
// #########################################################

HEADER_BINARY_FILE_START
          void post_construction_initialization();
HEADER_BINARY_FILE_END

// ***********************************************
//          NE Binary File Format Support
// ***********************************************

HEADER_NE_FILE_HEADER_START

     public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
          /* File format of an NE File Header. All fields are little endian.
           *
           * NOTES
           * 
           * e_sssp: The value specified in SS is an index (1-origin) into the segment table. If SS addresses the automatic data segment
           *         and SP is zero then SP is set to the address obtained by adding the size of the automatic data segment to the size
           *         of the stack. */
          struct NEFileHeader_disk {
               unsigned char e_magic[2];           /* 0x00 magic number "NE" */
               unsigned char e_linker_major;       /* 0x02 linker major version number */
               unsigned char e_linker_minor;       /* 0x03 linker minor version number */
               uint16_t    e_entrytab_rfo;         /* 0x04 entry table offset relative to start of header */
               uint16_t    e_entrytab_size;        /* 0x06 size of entry table in bytes */
               uint32_t    e_checksum;             /* 0x08 32-bit CRC of entire file (this word is taken a zero during the calculation) */
               uint16_t    e_flags1;               /* 0x0c file-level bit flags (see HeaderFlags1) */
               uint16_t    e_autodata_sn;          /* 0x0e auto data section number if (flags & 0x3)==0; else zero */
               uint16_t    e_bss_size;             /* 0x10 num bytes added to data segment for BSS */
               uint16_t    e_stack_size;           /* 0x12 num bytes added to data segment for stack (zero of SS!=DS registers) */
               uint32_t    e_csip;                 /* 0x14 section number:offset of CS:IP */
               uint32_t    e_sssp;                 /* 0x18 section number:offset of SS:SP (see note 1 above) */
               uint16_t    e_nsections;            /* 0x1c number of entries in the section table */
               uint16_t    e_nmodrefs;             /* 0x1e number of entries in the module reference table */
               uint16_t    e_nnonresnames;         /* 0x20 number of entries in the non-resident name table */
               uint16_t    e_sectab_rfo;           /* 0x22 offset of section table relative to start of header */
               uint16_t    e_rsrctab_rfo;          /* 0x24 offset of resource table relative to start of header */
               uint16_t    e_resnametab_rfo;       /* 0x26 offset of resident name table relative to start of header */
               uint16_t    e_modreftab_rfo;        /* 0x28 offset of module reference table relative to start of header */
               uint16_t    e_importnametab_rfo;    /* 0x2a offset of imported names table relative to start of header */
               uint32_t    e_nonresnametab_offset; /* 0x2c file offset of non-resident name table */
               uint16_t    e_nmovable_entries;     /* 0x30 number of movable entries in Entry Table */
               uint16_t    e_sector_align;         /* 0x32 sector alignment shift count (log2 of segment sector size) */
               uint16_t    e_nresources;           /* 0x34 number of resource entries */
               unsigned char e_exetype;            /* 0x36 executable type (2==windows) */
               unsigned char e_flags2;             /* 0x37 additional flags (see HeaderFlags2) */
               uint16_t    e_fastload_sector;      /* 0x38 sector offset to fast-load area (only for Windows) */
               uint16_t    e_fastload_nsectors;    /* 0x3a size of fast-load area in sectors (only for Windows) */
               uint16_t    e_res1;                 /* 0x3c reserved */
               uint16_t    e_winvers;              /* 0x3e expected version number for Windows (only for Windows) */
             }                                     /* 0x40 */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif

          /* Bit flags for the NE header 'e_flags' member.
           *
           * If HF_LIBRARY (bit 15) is set then the CS:IP registers point to an initialization procedure called with the value in the AX
           * register equal to the module handle. The initialization procedure must execute a far return to the caller. The resulting
           * value in AX is a status indicator (non-zero for success, zero for failure). */
          enum HeaderFlags1 {
               HF1_RESERVED         = 0x57f4,      /* Reserved bits */
               HF1_NO_DATA          = 0x0000,      /* (flags&0x03==0) => an exe not containing a data segment */
               HF1_SINGLE_DATA      = 0x0001,      /* Executable contains one data segment; set if file is a DLL */
               HF1_MULTIPLE_DATA    = 0x0002,      /* Exe with multiple data segments; set if a windows application */
               HF1_LOADER_SEGMENT   = 0x0800,      /* First segment contains code that loads the application */
               HF1_FATAL_ERRORS     = 0x2000,      /* Errors detected at link time; module will not load */
               HF1_LIBRARY          = 0x8000       /* Module is a library */
             };

          /* Bit flags for the NE header 'e_flags2' member. */
          enum HeaderFlags2 {
               HF2_RESERVED         = 0xf1,        /* Reserved bits */
               HF2_PROTECTED_MODE   = 0x02,        /* Windows 2.x application that runs in 3.x protected mode */
               HF2_PFONTS           = 0x04,        /* Windows 2.x application that supports proportional fonts */
               HF2_FASTLOAD         = 0x08         /* Executable contains a fast-load area */
             };

          SgAsmNEFileHeader(SgAsmGenericFile *f, rose_addr_t offset)
                : SgAsmGenericHeader(f), p_dos2_header(NULL), p_section_table(NULL), p_resname_table(NULL),
                p_nonresname_table(NULL), p_module_table(NULL), p_entry_table(NULL)
                {ctor(f, offset);}

       // virtual ~NEFileHeader() {}
          static bool is_NE (SgAsmGenericFile*);
          static SgAsmNEFileHeader *parse(SgAsmDOSFileHeader*);
          virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
          virtual const char *format_name() const $ROSE_OVERRIDE {return "NE";}
          virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;

     private:
          void ctor(SgAsmGenericFile *f, rose_addr_t offset);
          void *encode(SgAsmNEFileHeader::NEFileHeader_disk*) const;
HEADER_NE_FILE_HEADER_END

HEADER_NE_SECTION_START
     public:
          explicit SgAsmNESection(SgAsmNEFileHeader *fhdr)
                : SgAsmGenericSection(fhdr->get_file(), fhdr), p_st_entry(NULL), p_reloc_table(NULL)
                {}

       // virtual ~NESection() {}

          virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
          virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
       /* Accessors for protected/private data */
       // NESectionTableEntry *get_st_entry() {return st_entry;}
       // void set_st_entry(NESectionTableEntry *e) {st_entry=e;}
       // NERelocTable *get_reloc_table() {return reloc_table;}
       // void set_reloc_table(NERelocTable *t) {reloc_table=t;}
  // private:
       // NESectionTableEntry *st_entry;
       // NERelocTable *reloc_table;

HEADER_NE_SECTION_END



HEADER_NE_SECTION_TABLE_START
        public:
                explicit SgAsmNESectionTable(SgAsmNEFileHeader *fhdr)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr)
                        {ctor();}
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;

        private:
                void ctor();
HEADER_NE_SECTION_TABLE_END



HEADER_NE_NAME_TABLE_START
        public:
                SgAsmNENameTable(SgAsmNEFileHeader *fhdr, rose_addr_t offset)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr)
                        {ctor(offset);}
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
                std::vector<std::string> get_names_by_ordinal(unsigned ordinal);
        private:
                void ctor(rose_addr_t offset);
HEADER_NE_NAME_TABLE_END



HEADER_NE_MODULE_TABLE_START
        public:
                SgAsmNEModuleTable(SgAsmNEFileHeader *fhdr, SgAsmNEStringTable *strtab, rose_addr_t offset, rose_addr_t size)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr), p_strtab(strtab)
                        {ctor(offset, size);}
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
        private:
                void ctor(rose_addr_t offset, rose_addr_t size);
HEADER_NE_MODULE_TABLE_END



HEADER_NE_STRING_TABLE_START
        public:
                SgAsmNEStringTable(SgAsmNEFileHeader *fhdr, rose_addr_t offset, rose_addr_t size)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr)
                        {ctor(offset, size);}
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
                std::string get_string(rose_addr_t offset);
        private:
                void ctor(rose_addr_t offset, rose_addr_t size);
HEADER_NE_STRING_TABLE_END



HEADER_NE_ENTRY_TABLE_START
        public:
                SgAsmNEEntryTable(SgAsmNEFileHeader *fhdr, rose_addr_t offset, rose_addr_t size)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr)
                        {ctor(offset, size);}
                void populate_entries();
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
        private:
                void ctor(rose_addr_t offset, rose_addr_t size);
HEADER_NE_ENTRY_TABLE_END



HEADER_NE_RELOC_TABLE_START
        public:
                explicit SgAsmNERelocTable(SgAsmNEFileHeader *fhdr, SgAsmNESection *section)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr)
                        {ctor(section);}
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
        private:
                void ctor(SgAsmNESection*);
HEADER_NE_RELOC_TABLE_END



HEADER_NE_ENTRY_POINT_START
          enum NEEntryFlags {
               EF_ZERO             = 0x00, /* No flags set */
               EF_RESERVED         = 0xfc, /* Reserved bits */
               EF_EXPORTED         = 0x01, /* Exported */
               EF_GLOBAL           = 0x02  /* Uses a global (shared) data section */
             };

       // SgAsmNEEntryPoint();
          SgAsmNEEntryPoint(SgAsmNEEntryPoint::NEEntryFlags flags, unsigned int3f, unsigned s_idx, unsigned s_off);

          void dump(FILE*, const char *prefix, ssize_t idx) const;
       // NEEntryFlags flags;         /* bit flags */
       // unsigned int3f;             /* always 0x3fxx */
       // unsigned section_idx;       /* zero indicates unused entry */
       // unsigned section_offset;    /* byte offset into section */

HEADER_NE_ENTRY_POINT_END

HEADER_NE_RELOC_ENTRY_START

     public:

       /* NERelocEntry_disk -- variable size with multiple levels of 'union'. It's easier to just parse it in NERelocEntry::ctor()
        * than defining it here as a struct. */

          enum NERelocSrcType {
               RF_SRCTYPE_8OFF     = 0,            /* Byte offset */
               RF_SRCTYPE_WORDSEG  = 2,            /* Word segment, 16-bit selector */
               RF_SRCTYPE_16PTR    = 3,            /* 16-bit far pointer */
               RF_SRCTYPE_16OFF    = 5,            /* 16-bit offset */
               RF_SRCTYPE_32PTR    = 6,            /* 32-bit far pointer */
               RF_SRCTYPE_32OFF    = 7,            /* 32-bit offset */
               RF_SRCTYPE_NEARCALL = 8,            /* near call or jump, WORD/DWROD based on section attribute */
               RF_SRCTYPE_48PTR    = 11,           /* 48-bit pointer */
               RF_SRCTYPE_32OFF_b  = 13            /* 32-bit offset (not sure how this differs from case 7) */
             };

          enum NERelocTgtType {
               RF_TGTTYPE_IREF     = 0,            /* Internal reference */
               RF_TGTTYPE_IORD     = 1,            /* Imported (extern) ordinal */
               RF_TGTTYPE_INAME    = 2,            /* Imported (extern) name */
               RF_TGTTYPE_OSFIXUP  = 3             /* Operating system fixup */ 
             };

          enum NERelocModifiers {
               RF_MODIFIER_SINGLE  = 1,
               RF_MODIFIER_MULTI   = 3
             };

          enum NERelocFlags {
               RF_ADDITIVE         = 0x01,         /* add target to source rather than replace source with target */
               RF_RESERVED         = 0x02,         /* reserved bits */
               RF_2EXTRA           = 0x04,         /* relocation info has size with new two bytes at end */
               RF_32ADD            = 0x08,         /* addition with 32-bits rather than 16 */
               RF_16SECTION        = 0x10,         /* 16-bit object number & module name rather than 8-bit */
               RF_8ORDINAL         = 0x20          /* Ordinal is 8-bits rather than 16 */
             };

       // DQ (8/7/2008): At only (I hope) the risk of using more memory that required, break the union so that we can better support 
       // this in ROSETTA. One solution might be to implement a common base class of unsigned, unsigned, rose_addr_t; and then use member 
       // functions to access the data in the base class.
          struct iref_type
             { /*tgt_type==0x00: internal reference*/
               unsigned    sect_idx;       /* section index (1-origin) */
               unsigned    res1;           /* reserved */
               rose_addr_t      tgt_offset;
     
            // Added to support RTI support in ROSE
               friend std::ostream & operator<< ( std::ostream & os, const iref_type & x );

               iref_type();
             };

          struct iord_type { /*tgt_type==0x01: imported ordinal*/
               unsigned    modref;         /* 1-based index into import module table */
               unsigned    ordinal;
               rose_addr_t      addend;         /* value to add (only present for flags & RF_2EXTRA) */

            // Added to support RTI support in ROSE
               friend std::ostream & operator<< ( std::ostream & os, const iord_type & x );

               iord_type();
             };

          struct iname_type { /*tgt_type==0x02: imported name*/
               unsigned    modref;         /* 1-based index into import module table */
               unsigned    nm_off;         /* offset into import procedure names */
               rose_addr_t      addend;         /* value to add (only present for flags & RF_2EXTRA) */

            // Added to support RTI support in ROSE
               friend std::ostream & operator<< ( std::ostream & os, const iname_type & x );

               iname_type();
             };

          struct osfixup_type { /*tgt_type==0x03: operating system fixup*/
               unsigned    type;
               unsigned    res3;

            // Added to support RTI support in ROSE
               friend std::ostream & operator<< ( std::ostream & os, const osfixup_type & x );

               osfixup_type();
             };

          SgAsmNERelocEntry(SgAsmGenericSection *relocs, rose_addr_t at, rose_addr_t *rec_size);

          void ctor(SgAsmGenericSection*, rose_addr_t at, rose_addr_t *rec_size);
          rose_addr_t unparse(std::ostream&, const SgAsmGenericSection*, rose_addr_t spos) const;
          void dump(FILE*, const char *prefix, ssize_t idx) const;
       // NERelocSrcType      src_type;       /* low nibble of first byte of relocation record */
       // NERelocModifiers    modifier;       /* high nibble of first byte */
       // NERelocTgtType      tgt_type;       /* low two bits of second byte */
       // NERelocFlags        flags;          /* high six bits of second byte */
       // rose_addr_t              src_offset;

       // iref_type iref;
       // iord_type iord;
       // iname_type iname;
       // osfixup_type osfixup;

HEADER_NE_RELOC_ENTRY_END

HEADER_NE_SECTION_TABLE_ENTRY_START
     public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
       /* File format of a section table entry. All fields are little endian. */
          struct NESectionTableEntry_disk {
               uint16_t    sector;                 /* 0x00 File offset (sector size defined in hdr); zero means no file data */
               uint16_t    physical_size;          /* 0x02 Length of segment in file; zero means 64k if sector is non-zero */
               uint16_t    flags;                  /* 0x04 Segment bit flags */
               uint16_t    virtual_size;           /* 0x06 Total size of segment when mapped to memory; zero means 64k */
             }                                     /* 0x08 */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif

          enum NESectionFlags {
               SF_RESERVED         = 0x0e08,       /* these bits are reserved */

               SF_TYPE_MASK        = 0x0007,       /* segment-type field */
               SF_CODE             = 0x0000,       /* code-segment type */
               SF_DATA             = 0x0001,       /* data-segment (otherwise segment is code) */
               SF_ALLOC            = 0x0002,       /* loader allocates memory */
               SF_LOAD             = 0x0004,       /* load the segment */

               SF_MOVABLE          = 0x0010,       /* segment is not fixed */
               SF_PURE             = 0x0020,       /* segment is pure, or sharable; otherwise impure or non-sharable */
               SF_PRELOAD          = 0x0040,       /* segment will be preloaded; read-only if this is a data segment */
               SF_NOT_WRITABLE     = 0x0080,       /* code segment is execute only; data segment is read-only */
               SF_RELOCINFO        = 0x0100,       /* segment has relocation records */
               SF_DISCARDABLE      = 0x1000,       /* discardable */
               SF_DISCARD          = 0xf000        /* discard priority */
             };

          explicit SgAsmNESectionTableEntry(const SgAsmNESectionTableEntry::NESectionTableEntry_disk *disk);
       // virtual ~NESectionTableEntry() {};

          void *encode(SgAsmNESectionTableEntry::NESectionTableEntry_disk*) const;
          virtual void dump(FILE *f, const char *prefix, ssize_t idx) const {dump(f, prefix, idx, NULL);}
          void dump(FILE*, const char *prefix, ssize_t idx, SgAsmNEFileHeader *fhdr) const;
       /* These are the native-format versions of the same members described in the NESectionTableEntry_disk struct. */
       // unsigned    flags, sector;
       // rose_addr_t      physical_size, virtual_size;

     private:
          void ctor(const SgAsmNESectionTableEntry::NESectionTableEntry_disk*);

HEADER_NE_SECTION_TABLE_ENTRY_END



// ***********************************************
//          LE Binary File Format Support
// ***********************************************

HEADER_LE_FILE_HEADER_START

     public:
       // Overloaded base class virtual function
          const char *format_name() const $ROSE_OVERRIDE;

          static bool is_LE (SgAsmGenericFile*);
          static SgAsmLEFileHeader *parse(SgAsmDOSFileHeader*);

#ifdef _MSC_VER
# pragma pack (1)
#endif
       /* File format of an LE/LX File Header (they are identical except bytes 0x2c-0x2f) */
          struct LEFileHeader_disk {
              unsigned char e_magic[2];           /* 0x00 magic number "LX" */
              unsigned char e_byte_order;         /* 0x02 byte order (0=>little endian; otherwise big endian) */
              unsigned char e_word_order;         /* 0x03 word order (0=>little endian; otherwise big endian) */
              uint32_t    e_format_level;         /* 0x04 LX file format version number */
              uint16_t    e_cpu_type;             /* 0x08 1=>80286, 2=>80386, 3=>80486,4=80586, etc. (see ctor) */
              uint16_t    e_os_type;              /* 0x0a 0=>unknown, 1=>0S/2, 2=>Windows, 3=>DOS 4.x, 4=>Windows 386 */
              uint32_t    e_module_version;       /* 0x0c user-specified module version number */
              uint32_t    e_flags;                /* 0x10 bit flags (see LXFileHeaderFlags) */
              uint32_t    e_npages;               /* 0x14 number of physically contained pages (see e_page_size) */
              uint32_t    e_eip_section;          /* 0x18 the section number to which e_eip is relative */
              uint32_t    e_eip;                  /* 0x1c entry address relative to e_eip_section */
              uint32_t    e_esp_section;          /* 0x20 the section number to which e_esp is relative */
              uint32_t    e_esp;                  /* 0x24 starting stack address relative to e_esp_section */
              uint32_t    e_page_size;            /* 0x28 page size in bytes */
              uint32_t    e_lps_or_shift;         /* 0x2c size of last page (LE) or shift for page table's page offset field (LX) */
              uint32_t    e_fixup_sect_size;      /* 0x30 total size of fixup info in bytes (fixup page/record tables + import names) */
              uint32_t    e_fixup_sect_cksum;     /* 0x34 cryptographic checksum of all fixup info, or zero */
              uint32_t    e_loader_sect_size;     /* 0x38 size of memory resident tables (section table through per-page checksum table) */
              uint32_t    e_loader_sect_cksum;    /* 0x3c cryptographic checksum for all loader info, or zero */
              uint32_t    e_secttab_rfo;          /* 0x40 offset of section table relative to this header */
              uint32_t    e_secttab_nentries;     /* 0x44 number of entries in section table */
              uint32_t    e_pagetab_rfo;          /* 0x48 section page table offset relative to this header */
              uint32_t    e_iterpages_offset;     /* 0x4c section iterated pages offset (absolute file offset) */
              uint32_t    e_rsrctab_rfo;          /* 0x50 offset of resource table relative to this header */
              uint32_t    e_rsrctab_nentries;     /* 0x54 number of entries in the resource table */
              uint32_t    e_resnametab_rfo;       /* 0x58 offset of resident name table relative to this header */
              uint32_t    e_entrytab_rfo;         /* 0x5c offset of entry table relative to this header */
              uint32_t    e_fmtdirtab_rfo;        /* 0x60 offset of module format directives relative to this header */
              uint32_t    e_fmtdirtab_nentries;   /* 0x64 number of entries in module format directives table */
              uint32_t    e_fixup_pagetab_rfo;    /* 0x68 offset of fixup page table relative to this header */
              uint32_t    e_fixup_rectab_rfo;     /* 0x6c offset of fixup record table relative to this header */
              uint32_t    e_import_modtab_rfo;    /* 0x70 offset of import module name table relative to this header */
              uint32_t    e_import_modtab_nentries;/*0x74 number of entries in import module name table */
              uint32_t    e_import_proctab_rfo;   /* 0x78 offset of import procedure name table relative to this header */
              uint32_t    e_ppcksumtab_rfo;       /* 0x7c offset of per-page checksum table relative to this header */
              uint32_t    e_data_pages_offset;    /* 0x80 offset of data pages (absolute file offset) */
              uint32_t    e_preload_npages;       /* 0x84 number of preload pages (not respected by OS/2) */
              uint32_t    e_nonresnametab_offset; /* 0x88 offset of non-resident name table (absolute file offset) */
              uint32_t    e_nonresnametab_size;   /* 0x8c size of non-resident name table in bytes */
              uint32_t    e_nonresnametab_cksum;  /* 0x90 cryptographic checksum of the non-resident name table */
              uint32_t    e_auto_ds_section;      /* 0x94 auto data segment section number (not used by 32-bit modules) */
              uint32_t    e_debug_info_rfo;       /* 0x98 offset of debug information relative to this header */
              uint32_t    e_debug_info_size;      /* 0x9c size of debug information in bytes */
              uint32_t    e_num_instance_preload; /* 0xa0 number of instance data pages found in the preload section */
              uint32_t    e_num_instance_demand;  /* 0xa4 number of instance data pages found in the demand section */
              uint32_t    e_heap_size;            /* 0xa8 number of bytes added to auto data segment by loader (not used by 32-bit) */
          }                                       /* 0xac */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
          __attribute__((packed))
#endif
#endif
          ;
#ifdef _MSC_VER
# pragma pack ()
#endif

          enum LEFileHeaderFlags {
              HF_RESERVED         = 0xbffc5ccb,   /* Reserved bits */
              HF_PROC_LIB_INIT    = 0x00000004,   /* Per-process library initialization; not used for executables */
              HF_IFIXUPS_APPLIED  = 0x00000010,   /* Sections have preferred load addresses and internal relocs have been applied */
              HF_EFIXUPS_APPLIED  = 0x00000020,   /* External fixups for the module have been applied */
              HF_PM_WINDOW_NO     = 0x00000100,   /* Incompatible with PM windowing */
              HF_PM_WINDOW_OK     = 0x00000200,   /* Compatible with PM windowing */
              HF_PM_WINDOW_USE    = 0x00000300,   /* Uses PM windowing API */
              HF_NOT_LOADABLE     = 0x00002000,   /* Module is not loadable (has errors or incrementally linked) */
              HF_PROC_LIB_TERM    = 0x40000000,   /* Per-process library termination; not used for executables */
    
              HF_MODTYPE_MASK     = 0x00038000,   /* Module type mask */
              HF_MODTYPE_PROG     = 0x00000000,   /* Program module (other modules cannot link to this one) */
              HF_MODTYPE_LIB      = 0x00008000,   /* Library module */
              HF_MODTYPE_PLIB     = 0x00018000,   /* Protected memory library module */
              HF_MODTYPE_PDEV     = 0x00020000,   /* Physical device driver module */
              HF_MODTYPE_VDEV     = 0x00028000    /* Virtual device driver module */
          };

          SgAsmLEFileHeader(SgAsmGenericFile *f, rose_addr_t offset)
                : SgAsmGenericHeader(f), p_dos2_header(NULL), p_section_table(NULL), p_page_table(NULL),
                p_resname_table(NULL), p_nonresname_table(NULL), p_entry_table(NULL), p_reloc_table(NULL)
                {ctor(f, offset);}

       // virtual ~LEFileHeader() {}

          virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
       // virtual const char *format_name() const;
          virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
     private:
          void ctor(SgAsmGenericFile *f, rose_addr_t offset);
          void *encode(ByteOrder::Endianness sex, SgAsmLEFileHeader::LEFileHeader_disk*) const;
HEADER_LE_FILE_HEADER_END



HEADER_LE_SECTION_START
        public:
                explicit SgAsmLESection(SgAsmLEFileHeader *fhdr)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr), p_st_entry(NULL)
                        {}
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
HEADER_LE_SECTION_END



HEADER_LE_SECTION_TABLE_START
        public:
                SgAsmLESectionTable(SgAsmLEFileHeader *fhdr, rose_addr_t offset, rose_addr_t size)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr)
                        {ctor(offset, size);}
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
        private:
                void ctor(rose_addr_t offset, rose_addr_t size);
HEADER_LE_SECTION_TABLE_END



HEADER_LE_NAME_TABLE_START
        public:
                /* This table contains a module name followed by the list of exported function names. Each name is associated with
                 * an "ordinal" which serves as an index into the Entry Table. The ordinal for the first string (module name) is
                 * meaningless and should be zero. In the non-resident name table the first entry is a module description and the
                 * functions are not always resident in system memory (they are discardable). */
                SgAsmLENameTable(SgAsmLEFileHeader *fhdr, rose_addr_t offset)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr)
                        {ctor(offset);}
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
        private:
                void ctor(rose_addr_t offset);
HEADER_LE_NAME_TABLE_END



HEADER_LE_PAGE_TABLE_START
        public:
                SgAsmLEPageTable(SgAsmLEFileHeader *fhdr, rose_addr_t offset, rose_addr_t size)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr)
                        {ctor(offset, size);}
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
                SgAsmLEPageTableEntry *get_page(size_t idx);
        private:
                void ctor(rose_addr_t offset, rose_addr_t size);
HEADER_LE_PAGE_TABLE_END



HEADER_LE_ENTRY_TABLE_START
        public:
                SgAsmLEEntryTable(SgAsmLEFileHeader *fhdr, rose_addr_t offset)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr)
                        {ctor(offset);}
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
        private:
                void ctor(rose_addr_t offset);
HEADER_LE_ENTRY_TABLE_END



HEADER_LE_RELOC_TABLE_START
        public:
                SgAsmLERelocTable(SgAsmLEFileHeader *fhdr, rose_addr_t offset)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr)
                        {ctor(offset);}
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
        private:
                void ctor(rose_addr_t offset);
HEADER_LE_RELOC_TABLE_END



HEADER_LE_PAGE_TABLE_ENTRY_START
     public:
       /* The object page table provides information about a logical page in a section. A logical page may be an enumerated page, a
        * pseudo page, or an iterated page. The page table allows for efficient access to a page when a page fault occurs, while
        * still allowing the physical page to be located in the preload page, demand load page, or iterated data page sections of the
        * executable file. Entries in the page table use 1-origin indices.  This table is parallel with the Fixup Page Table (they
        * are both indexed by the logical page number). */

#ifdef _MSC_VER
# pragma pack (1)
#endif
       /* File format for a page table entry */
          struct LEPageTableEntry_disk {
               uint16_t            pageno_hi;
               unsigned char       pageno_lo;
               unsigned char       flags;
             }
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif

          SgAsmLEPageTableEntry(ByteOrder::Endianness sex, const SgAsmLEPageTableEntry::LEPageTableEntry_disk *disk);

          void dump(FILE*, const char *prefix, ssize_t idx) const;
          void *encode(ByteOrder::Endianness, SgAsmLEPageTableEntry::LEPageTableEntry_disk*) const;

       // unsigned get_pageno() {return pageno;}

     private:
          void ctor(ByteOrder::Endianness, const SgAsmLEPageTableEntry::LEPageTableEntry_disk*);

       // unsigned    pageno;
       // unsigned    flags;

HEADER_LE_PAGE_TABLE_ENTRY_END

HEADER_LE_ENTRY_POINT_START

     public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
       /* If 0x01 bit of "flags" is clear then the remainder (next 9 bytes) of the entry point is not stored in the file and the
        * next entry point description follows immediately after the flag. */
          struct LEEntryPoint_disk {
              uint8_t     flags;          /* 0x00 Bit flags (0x01=>non-empty bundle; 0x02=>32-bit entry*/
              uint16_t    objnum;         /* 0x01 Object number */
              uint8_t     entry_type;     /* 0x03 Flags for entry type */
              uint32_t    entry_offset;   /* 0x04 Offset of entry point */
              uint16_t    res1;           /* 0x08 Reserved */
          }                               /* 0x0a */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif

          SgAsmLEEntryPoint(ByteOrder::Endianness sex, const SgAsmLEEntryPoint::LEEntryPoint_disk *disk);
          SgAsmLEEntryPoint(ByteOrder::Endianness sex, unsigned flags);

          rose_addr_t unparse(std::ostream&, ByteOrder::Endianness, const SgAsmGenericSection*, rose_addr_t spos) const;
          void dump(FILE*, const char *prefix, ssize_t idx) const;
     private:
          void ctor(ByteOrder::Endianness, const SgAsmLEEntryPoint::LEEntryPoint_disk*);

       // std::vector<LEEntryPoint> entries;
       // unsigned flags, objnum, entry_type, res1;
       // rose_addr_t entry_offset;

HEADER_LE_ENTRY_POINT_END

HEADER_LE_SECTION_TABLE_ENTRY_START

     public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
       /* File format of a section table entry. Fields are big- or little-endian depending on file header. */
          struct LESectionTableEntry_disk {
               uint32_t    mapped_size;            /* 0x00 virtual segment size in bytes */
               uint32_t    base_addr;              /* 0x04 relocation base address */
               uint32_t    flags;                  /* 0x08 bit flags, see LESectionFlags */
               uint32_t    pagemap_index;          /* 0x0c */
               uint32_t    pagemap_nentries;       /* 0x10 number of entries in the page map */
               uint32_t    res1;                   /* 0x14 reserved */
             }                                     /* 0x18 */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif

       /* SF_BIG_BIT: The "big/default" bit, for data segments, controls the setting of the Big bit in the segment descriptor. (The
        *             Big bit, or B-bit, determines whether ESP or SP is used as the stack pointer.) For code segments, this bit
        *             controls the setting of the Default bit in the segment descriptor. (The Default bit, or D-bit, determines
        *             whether the default word size is 32-bits or 16-bits. It also affects the interpretation of the instruction
        *             stream.) */
          enum LESectionFlags {
               SF_RESERVED         = 0xffff0800,   /* Reserved bits (FIXME) */
    
               SF_READABLE         = 0x00000001,   /**< Read permission granted when mapped */
               SF_WRITABLE         = 0x00000002,   /**< Write permission granted when mapped */
               SF_EXECUTABLE       = 0x00000004,   /**< Execute permission granted when mapped */
    
               SF_RESOURCE         = 0x00000008,   /**< Section contains resource objects */
               SF_DISCARDABLE      = 0x00000010,   /**< Discardable section */
               SF_SHARED           = 0x00000020,   /**< Section is shared */
               SF_PRELOAD_PAGES    = 0x00000040,   /**< Section has preload pages */
               SF_INVALID_PAGES    = 0x00000080,   /**< Section has invalid pages */

               SF_TYPE_MASK        = 0x00000300,        /*NO_STRINGIFY*/
               SF_TYPE_NORMAL      = 0x00000000,
               SF_TYPE_ZERO        = 0x00000100,   /**< Section has zero-filled pages */
               SF_TYPE_RESIDENT    = 0x00000200,   /**< Section is resident (valid for VDDs and PDDs only) */
               SF_TYPE_RESCONT     = 0x00000300,   /**< Section is resident and contiguous */
    
               SF_RES_LONG_LOCK    = 0x00000400,   /**< Section is resident and "long-lockable" (VDDs and PDDs only) */
               SF_1616_ALIAS       = 0x00001000,   /**< 16:16 alias required (80x86 specific) */
               SF_BIG_BIT          = 0x00002000,   /**< Big/default bit setting (80x86 specific); see note above */
               SF_CODE_CONFORM     = 0x00004000,   /**< Section is conforming for code (80x86 specific) */
               SF_IO_PRIV          = 0x00008000    /**< Section I/O privilege level (80x86 specific; used only for 16:16 alias objects) */
             };

          SgAsmLESectionTableEntry(ByteOrder::Endianness sex, const SgAsmLESectionTableEntry::LESectionTableEntry_disk *disk);
       // virtual ~LESectionTableEntry() {};

          void *encode(ByteOrder::Endianness, SgAsmLESectionTableEntry::LESectionTableEntry_disk*) const;
          virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;
       /* These are the native-format versions of the same members described in the NESectionTableEntry_disk struct. */
       // unsigned    flags, pagemap_index, pagemap_nentries, res1;
       // rose_addr_t      mapped_size, base_addr;

     private:
          void ctor(ByteOrder::Endianness, const SgAsmLESectionTableEntry::LESectionTableEntry_disk*);

HEADER_LE_SECTION_TABLE_ENTRY_END




// ***********************************************
//          DOS Binary File Format Support
// ***********************************************





HEADER_BINARY_RET_START
   void append_dest( SgAsmStatement* instruction );     
HEADER_BINARY_RET_END

// ************************************
//           DWARF SUPPORT
// ************************************


HEADER_DWARF_COMPILATION_UNIT_START

     public:
          SgAsmDwarfConstructList* get_children() $ROSE_OVERRIDE;

HEADER_DWARF_COMPILATION_UNIT_END



HEADER_DWARF_LINE_LIST_START
       // Once the maps are setup using a valid SgAsmDwarfCompilationUnit, NULL is an acceptable value.
      //! Support for building maps to and from instruction addresses to source positions (files, line numbers, column numbers).
          static DwarfInstructionSourceMapReturnType buildInstructionAddressSourcePositionMaps( SgAsmDwarfCompilationUnit* dwarf_cu = NULL );

      //! Output information about instruction address <--> source position
          void display( const std::string & label );

          static std::pair<uint64_t,uint64_t> instructionRange();
          static std::pair<LineColumnFilePosition,LineColumnFilePosition> sourceCodeRange( int file_id );

          static uint64_t sourceCodeToAddress ( FileIdLineColumnFilePosition sourcePosition );
          static FileIdLineColumnFilePosition addressToSourceCode ( uint64_t address );
HEADER_DWARF_LINE_LIST_END

HEADER_DWARF_CONSTRUCT_START
     public:
      //! Factory pattern to build IR nodes based on the tag
          static SgAsmDwarfConstruct* createDwarfConstruct( int tag, int nesting_level, uint64_t offset, uint64_t overall_offset );

          virtual SgAsmDwarfConstructList* get_children();
HEADER_DWARF_CONSTRUCT_END

HEADER_DWARF_SUBPROGRAM_START
     public:
          SgAsmDwarfConstructList* get_children() $ROSE_OVERRIDE;
HEADER_DWARF_SUBPROGRAM_END

HEADER_DWARF_STRUCTURE_TYPE_START
     public:
          SgAsmDwarfConstructList* get_children() $ROSE_OVERRIDE;
HEADER_DWARF_STRUCTURE_TYPE_END

HEADER_DWARF_ARRAY_TYPE_START
     public:
          SgAsmDwarfConstructList* get_children() $ROSE_OVERRIDE;
HEADER_DWARF_ARRAY_TYPE_END

HEADER_DWARF_LEXICAL_BLOCK_START
     public:
          SgAsmDwarfConstructList* get_children() $ROSE_OVERRIDE;
HEADER_DWARF_LEXICAL_BLOCK_END

HEADER_DWARF_INLINED_SUBROUTINE_START
     public:
          SgAsmDwarfConstructList* get_children() $ROSE_OVERRIDE;
HEADER_DWARF_INLINED_SUBROUTINE_END

HEADER_DWARF_ENUMERATION_TYPE_START
     public:
          SgAsmDwarfConstructList* get_children() $ROSE_OVERRIDE;
HEADER_DWARF_ENUMERATION_TYPE_END

HEADER_DWARF_SUBROUTINE_TYPE_START
     public:
          SgAsmDwarfConstructList* get_children() $ROSE_OVERRIDE;
HEADER_DWARF_SUBROUTINE_TYPE_END

HEADER_DWARF_UNION_TYPE_START
     public:
          SgAsmDwarfConstructList* get_children() $ROSE_OVERRIDE;
HEADER_DWARF_UNION_TYPE_END

HEADER_DWARF_NAMESPACE_START
     public:
          SgAsmDwarfConstructList* get_children() $ROSE_OVERRIDE;
HEADER_DWARF_NAMESPACE_END

HEADER_DWARF_CLASS_TYPE_START
     public:
          SgAsmDwarfConstructList* get_children() $ROSE_OVERRIDE;
HEADER_DWARF_CLASS_TYPE_END

HEADER_DWARF_COMMON_BLOCK_START
     public:
          SgAsmDwarfConstructList* get_children() $ROSE_OVERRIDE;
HEADER_DWARF_COMMON_BLOCK_END


/* --------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------- */

SOURCE_BINARY_RET_START
void
SgAsmx86Ret::append_dest( SgAsmStatement* statement )
   {
     p_dest.push_back(statement);
   }

SOURCE_BINARY_RET_END



SOURCE_BINARY_OPERAND_LIST_START
void
SgAsmOperandList::append_operand( SgAsmExpression* operand )
   {
  /* implemented directly until we can fix how the statementList is built */
     p_operands.push_back(operand);
   }

SOURCE_BINARY_OPERAND_LIST_END



SOURCE_BINARY_DATA_STRUCTURE_START
void
SgAsmSynthesizedDataStructureDeclaration::append_declaration( SgAsmSynthesizedDeclaration* declaration )
   {
     p_declarationList.push_back(declaration);
   }

SOURCE_BINARY_DATA_STRUCTURE_END

// *************************************
//      Binary File Format Support
// *************************************


SOURCE_PE_COFF_SYMBOL_START
SgAsmCoffSymbol::SgAsmCoffSymbol(SgAsmPEFileHeader *fhdr, SgAsmGenericSection *symtab, SgAsmGenericSection *strtab, size_t idx)
   : p_st_name_offset(0), p_st_section_num(0), p_st_type(0), p_st_storage_class(0), p_st_num_aux_entries(0)
   {
#ifdef ROSE_BUILD_BINARY_ANALYSIS_SUPPORT
     ctor(fhdr, symtab, strtab, idx);
#else
     printf ("Error: ROSE not configured for binary analysis (this is a language specific build) \n");
     ROSE_ASSERT(false);
#endif
   }

SOURCE_PE_COFF_SYMBOL_END





SOURCE_NE_ENTRY_POINT_START

//SgAsmNEEntryPoint::SgAsmNEEntryPoint()
//   : p_flags((SgAsmNEEntryPoint::EF_ZERO), p_int3f(0), p_section_idx(0), p_section_offset(0)
//   {}

SgAsmNEEntryPoint::SgAsmNEEntryPoint(SgAsmNEEntryPoint::NEEntryFlags flags, unsigned int3f, unsigned s_idx, unsigned s_off)
   : p_flags(flags), p_int3f(int3f), p_section_idx(s_idx), p_section_offset(s_off)
   {
   }

SOURCE_NE_ENTRY_POINT_END

SOURCE_NE_RELOC_ENTRY_START
SgAsmNERelocEntry::SgAsmNERelocEntry(SgAsmGenericSection *relocs, rose_addr_t at, rose_addr_t *rec_size)
   {
#ifdef ROSE_BUILD_BINARY_ANALYSIS_SUPPORT
     ctor(relocs, at, rec_size);
#else
     printf ("Error: ROSE not configured for binary analysis (this is a language specific build) \n");
     ROSE_ASSERT(false);
#endif
   }

SOURCE_NE_RELOC_ENTRY_END

SOURCE_NE_SECTION_TABLE_ENTRY_START
SgAsmNESectionTableEntry::SgAsmNESectionTableEntry(const SgAsmNESectionTableEntry::NESectionTableEntry_disk *disk)
   {
#ifdef ROSE_BUILD_BINARY_ANALYSIS_SUPPORT
     ctor(disk);
#else
     printf ("Error: ROSE not configured for binary analysis (this is a language specific build) \n");
     ROSE_ASSERT(false);
#endif
   }

SOURCE_NE_SECTION_TABLE_ENTRY_END





SOURCE_LE_PAGE_TABLE_ENTRY_START
SgAsmLEPageTableEntry::SgAsmLEPageTableEntry(ByteOrder::Endianness sex, const SgAsmLEPageTableEntry::LEPageTableEntry_disk *disk)
   : p_pageno(0), p_flags(0)
   {
#ifdef ROSE_BUILD_BINARY_ANALYSIS_SUPPORT
     ctor(sex, disk);
#else
     printf ("Error: ROSE not configured for binary analysis (this is a language specific build) \n");
     ROSE_ASSERT(false);
#endif
   }

SOURCE_LE_PAGE_TABLE_ENTRY_END

SOURCE_LE_ENTRY_POINT_START
SgAsmLEEntryPoint::SgAsmLEEntryPoint(ByteOrder::Endianness sex, const SgAsmLEEntryPoint::LEEntryPoint_disk *disk)
   : p_flags(0), p_objnum(0), p_entry_type(0), p_res1(0), p_entry_offset(0)
   {
#ifdef ROSE_BUILD_BINARY_ANALYSIS_SUPPORT
     ctor(sex, disk);
#else
     printf ("Error: ROSE not configured for binary analysis (this is a language specific build) \n");
     ROSE_ASSERT(false);
#endif
   }

SgAsmLEEntryPoint::SgAsmLEEntryPoint(ByteOrder::Endianness sex, unsigned flags)
   : p_flags(flags), p_objnum(0), p_entry_type(0), p_res1(0), p_entry_offset(0)
   {
   }

SOURCE_LE_ENTRY_POINT_END

SOURCE_LE_SECTION_TABLE_ENTRY_START
SgAsmLESectionTableEntry::SgAsmLESectionTableEntry(ByteOrder::Endianness sex, const SgAsmLESectionTableEntry::LESectionTableEntry_disk *disk)
   {
#ifdef ROSE_BUILD_BINARY_ANALYSIS_SUPPORT
     ctor(sex, disk);
#else
     printf ("Error: ROSE not configured for binary analysis (this is a language specific build) \n");
     ROSE_ASSERT(false);
#endif
   }

SOURCE_LE_SECTION_TABLE_ENTRY_END




SOURCE_DWARF_COMPILATION_UNIT_START

SgAsmDwarfConstructList*
SgAsmDwarfCompilationUnit::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_language_constructs == NULL)
          p_language_constructs = new SgAsmDwarfConstructList();

     return p_language_constructs;
   }

SOURCE_DWARF_COMPILATION_UNIT_END

SOURCE_DWARF_LINE_LIST_START

DwarfInstructionSourceMapReturnType
SgAsmDwarfLineList::buildInstructionAddressSourcePositionMaps( SgAsmDwarfCompilationUnit* dwarf_cu )
   {
  // SgInstructionAddressSourcePositionMapPtrList* instruction_source_code_map = new SgInstructionAddressSourcePositionMapPtrList;
  // SgSourcePositionInstructionAddressMapPtrList* source_code_instruction_map = new SgSourcePositionInstructionAddressMapPtrList;

  // Build this as static local data
     static SgInstructionAddressSourcePositionMapPtrList* instruction_source_code_map = NULL;

     bool recomputeMap = false;
     if (instruction_source_code_map == NULL)
        {
          recomputeMap = true;
          instruction_source_code_map = new SgInstructionAddressSourcePositionMapPtrList;
        }

     ROSE_ASSERT(instruction_source_code_map != NULL);

     static SgSourcePositionInstructionAddressMapPtrList* source_code_instruction_map = NULL;
     if (source_code_instruction_map == NULL)
          source_code_instruction_map = new SgSourcePositionInstructionAddressMapPtrList;
     ROSE_ASSERT(source_code_instruction_map != NULL);

     if (recomputeMap == true)
        {
          ROSE_ASSERT(dwarf_cu != NULL);
          ROSE_ASSERT(dwarf_cu->get_line_info() != NULL);

          SgAsmDwarfLinePtrList & line_list = dwarf_cu->get_line_info()->get_line_list();

          int listSize = (int) line_list.size();
          for (int i = 0; i < listSize; i++)
             {
            // Loop over each of the entries in the Dwarf line section.
               uint64_t address = line_list[i]->get_address();

            // Note that file_id values are already in terms of the Sg_File_Info maps 
            // between file name integers and file name strings.
               int file_id      = line_list[i]->get_file_id();

               int line         = line_list[i]->get_line();
               int column       = line_list[i]->get_column();

            // printf ("address = 0x%lx file_id = %d line = %d  column = %d \n",address,file_id,line,column);

               FileIdLineColumnFilePosition file_info(file_id,std::pair<int,int>(line,column));

            // This works for stp::map, but for std::multimap
            // instruction_source_code_map->operator[](address)   = file_info;
            // source_code_instruction_map->operator[](file_info) = address;

            // This is the std::multiset version ...
               instruction_source_code_map->insert(AddressFileIdLineColumnFilePositionPair(address,file_info));
               source_code_instruction_map->insert(FileIdLineColumnFilePositionAddressPair(file_info,address));
             }
        }
       else
        {
       // printf ("Maps were computed previously \n");
        }

     DwarfInstructionSourceMapReturnType returnValue(instruction_source_code_map,source_code_instruction_map);

     return returnValue;
   }

SOURCE_DWARF_LINE_LIST_END

SOURCE_DWARF_CONSTRUCT_START

SgAsmDwarfConstructList*
SgAsmDwarfConstruct::get_children()
   {
     ROSE_ASSERT(this != NULL);

#if 0
     printf ("Error: base class of virtual function called by mistake: class_name = %s \n",class_name().c_str());
     ROSE_ASSERT(false);
#else
     printf ("Warning: base class of virtual function called by mistake: class_name = %s \n",class_name().c_str());
#endif
     return NULL;
   }

SOURCE_DWARF_CONSTRUCT_END


SOURCE_DWARF_SUBPROGRAM_START

SgAsmDwarfConstructList*
SgAsmDwarfSubprogram::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_SUBPROGRAM_END

SOURCE_DWARF_STRUCTURE_TYPE_START

SgAsmDwarfConstructList*
SgAsmDwarfStructureType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_STRUCTURE_TYPE_END

SOURCE_DWARF_ARRAY_TYPE_START

SgAsmDwarfConstructList*
SgAsmDwarfArrayType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_ARRAY_TYPE_END


SOURCE_DWARF_LEXICAL_BLOCK_START

SgAsmDwarfConstructList*
SgAsmDwarfLexicalBlock::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_LEXICAL_BLOCK_END


SOURCE_DWARF_INLINED_SUBROUTINE_START

SgAsmDwarfConstructList*
SgAsmDwarfInlinedSubroutine::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_INLINED_SUBROUTINE_END


SOURCE_DWARF_ENUMERATION_TYPE_START

SgAsmDwarfConstructList*
SgAsmDwarfEnumerationType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_ENUMERATION_TYPE_END


SOURCE_DWARF_SUBROUTINE_TYPE_START

SgAsmDwarfConstructList*
SgAsmDwarfSubroutineType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_SUBROUTINE_TYPE_END


SOURCE_DWARF_UNION_TYPE_START

SgAsmDwarfConstructList*
SgAsmDwarfUnionType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_UNION_TYPE_END


SOURCE_DWARF_NAMESPACE_START

SgAsmDwarfConstructList*
SgAsmDwarfNamespace::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_NAMESPACE_END


SOURCE_DWARF_CLASS_TYPE_START

SgAsmDwarfConstructList*
SgAsmDwarfClassType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_CLASS_TYPE_END


SOURCE_DWARF_COMMON_BLOCK_START

SgAsmDwarfConstructList*
SgAsmDwarfCommonBlock::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_COMMON_BLOCK_END


